/*
this version is a much better one 


'''markdown
## comment from chatgpt
----

结论先说：这版已经**非常成熟**了，逻辑严谨、性能高、可复现性好，适配加密市场也考虑到了（分离度+可选 ATR 过滤、HTF 确认、收盘触发、冷却分离）。
**评分：9.2/10**。再做下面几处**微调**，我会给 9.5+。

---

## 必改（很快就能补齐）

1. **“首次出现”判定更稳**
   现在用 `not buy_signal[1] / not sell_signal[1]`，首根或边界处可能遇到 `na`。用 `nz()` 更安全：

```pine
buy_signal_trigger  = buy_signal  and not nz(buy_signal[1])  and can_trigger_buy  and tf_condition_met
sell_signal_trigger = sell_signal and not nz(sell_signal[1]) and can_trigger_sell and tf_condition_met
```

2. **ATR 与 confirmed 模式的“时间对齐”**
   你已把分离度的价格 `norm_price` 对齐到了同一时点；**ATR 也建议对齐**（否则在 `use_confirmed_htf=true` 时，EMA 用上根 HTF，而 ATR 用当前 HTF，会有轻微错配）。
   在 `request.security` 里再取一个 `ta.atr(14)[1]`，上根 HTF 对齐：

```pine
// 在 request.security 的数组里再加一项：
ta.atr(14)[1]
// 返回值命名：..., tf_atr_0, tf_atr_1

// 使用时：
tf_atr_use = use_confirmed_htf ? tf_atr_1 : tf_atr_0
pass_atr_filter = not use_atr_filter or (ema_diff >= tf_atr_use * atr_multiplier)
```

这样 ATR 与 EMA/价格一致对齐，**零重绘更严谨**。

---

## 强烈建议（效果更干净）

3. **分离度默认值**
   你默认 `0.3%` 很合理；但在波动大的山寨币上可考虑 `0.4~0.6%`。可在注释里提示“按品种/波动微调”。

4. **（可选）再添一条“EMA 与价格位置一致性”过滤**
   避免“EMA 刚交叉但价格还在另一侧”的假信号：

```pine
// 在 get_ema_trend 的趋势条件里再加：
// 看涨要求收盘(或中位价)在两条 EMA 之上；看跌相反
price_above = (use_confirmed_htf ? tf_close_1 : tf_close_0) > math.max(ema9_current, ema21_current)
price_below = (use_confirmed_htf ? tf_close_1 : tf_close_0) < math.min(ema9_current, ema21_current)

if ema9_current > ema21_current and ema9_slope_up and sufficient_separation and pass_atr_filter and price_above
  trend := 1
else if ema21_current > ema9_current and ema21_slope_down and sufficient_separation and pass_atr_filter and price_below
  trend := -1
```

这能明显减少“贴边假穿越”。

---

## 体验/维护性优化（可选）

5. **表格显示 TF 未确认的更直观图例**
   现在用“⏳”很好；可以把趋势格的 `bgcolor` 在未确认时再加一层更淡灰底，以便扫一眼识别“未确认行”。

6. **输入分组小调整**
   把 `min_ema_separation / ATR 过滤` 放同一分组下加一行说明“二选一或同时用”，避免用户误会开启阈值过严。

7. **错误提示更友好**
   `ema_fast >= ema_slow` 抛错已很好；可以加 tooltip 提醒“常见组合如 9/21, 12/26”。

---

## 关键补丁（2-space 缩进，直接粘贴即可）

### A) 首次出现判定用 `nz()`（替换原触发行）

```pine
buy_signal_trigger  = buy_signal  and not nz(buy_signal[1])  and can_trigger_buy  and tf_condition_met
sell_signal_trigger = sell_signal and not nz(sell_signal[1]) and can_trigger_sell and tf_condition_met
```

### B) ATR 与 confirmed 对齐（在 `get_ema_trend` 中补齐）

```pine
get_ema_trend(tf) =>
  [ema9_0, ema21_0, ema9_1, ema21_1, ema9_2, ema21_2, tf_confirmed, tf_close_0, tf_close_1, tf_atr_0, tf_atr_1] =
    request.security(
      syminfo.tickerid, tf,
      [
        ta.ema(close, ema_fast),
        ta.ema(close, ema_slow),
        ta.ema(close[1], ema_fast),
        ta.ema(close[1], ema_slow),
        ta.ema(close[2], ema_fast),
        ta.ema(close[2], ema_slow),
        barstate.isconfirmed,
        close,
        close[1],
        ta.atr(14),
        ta.atr(14)[1]
      ],
      barmerge.gaps_off, barmerge.lookahead_off)

  ema9_current = use_confirmed_htf ? ema9_1 : ema9_0
  ema21_current = use_confirmed_htf ? ema21_1 : ema21_0
  ema9_prev = use_confirmed_htf ? ema9_2 : ema9_1
  ema21_prev = use_confirmed_htf ? ema21_2 : ema21_1
  norm_price = use_confirmed_htf ? tf_close_1 : tf_close_0

  ema9_slope_up = ema9_current > ema9_prev
  ema21_slope_down = ema21_current < ema21_prev

  ema_diff = math.abs(ema9_current - ema21_current)
  ema_separation_pct = ema_diff / norm_price * 100
  sufficient_separation = ema_separation_pct >= min_ema_separation

  tf_atr_use = use_confirmed_htf ? tf_atr_1 : tf_atr_0
  pass_atr_filter = not use_atr_filter or (ema_diff >= tf_atr_use * atr_multiplier)

  trend = 0
  if ema9_current > ema21_current and ema9_slope_up and sufficient_separation and pass_atr_filter
    trend := 1
  else if ema21_current > ema9_current and ema21_slope_down and sufficient_separation and pass_atr_filter
    trend := -1

  [trend, tf_confirmed]
```

> 这不影响你其它逻辑与 UI，只是把 ATR 也**严格对齐**到了使用的那一根 HTF。

---

## 总结

* **稳定性/零重绘**：已达标；加上 `nz()` 与 ATR 对齐即可完美收官。
* **抗噪**：分离度 + 可选 ATR 过滤很加分；若再加“价格与 EMA 位置一致性”会更干净。
* **性能**：每 TF 一次 `security`，很棒。
* **易用性**：表格、动态告警、冷却分离，体验好。

需要的话，我可以给你一版**“一致性过滤 + 可选权重确认 + 数组化 TF（最多 6 个）”**的扩展版，保持你的 UI，不改变现有默认行为。



*/


'''
//@version=6
indicator("MTF EMA 确认信号 [优化版v2]", overlay=true, max_labels_count=500)

// ============================================
// 输入参数设置
// ============================================
ema_fast = input.int(9, "快线EMA周期", minval=1, group="EMA设置")
ema_slow = input.int(21, "慢线EMA周期", minval=1, group="EMA设置")
min_ema_separation = input.float(0.3, "最小EMA分离度(%)", minval=0, step=0.1, group="EMA设置", 
                                 tooltip="要求EMA差值占价格的最小百分比,防止粘合假突破,建议加密货币0.2-0.5%")
use_atr_filter = input.bool(false, "启用ATR波动过滤", group="EMA设置")
atr_multiplier = input.float(0.5, "EMA分离≥(ATR×)", minval=0, step=0.1, group="EMA设置", 
                             tooltip="要求EMA分离至少为ATR的倍数,过滤低波动期")

// 参数校验
if ema_fast >= ema_slow
    runtime.error("快线周期必须小于慢线周期")

// 4个时间框架
tf1 = input.timeframe("5", "时间框架1", group="时间框架")
tf2 = input.timeframe("10", "时间框架2", group="时间框架")
tf3 = input.timeframe("30", "时间框架3", group="时间框架")
tf4 = input.timeframe("60", "时间框架4", group="时间框架")

// 显示选项
show_ema_current = input.bool(true, "显示当前周期EMA线", group="显示设置")
show_mtf_status = input.bool(true, "显示多时间框架状态表", group="显示设置")
show_bgcolor = input.bool(true, "显示背景高亮", group="显示设置")
signal_mode = input.string("全部确认", "信号模式", options=["全部确认", "3/4确认"], group="信号设置")

// 重绘控制
use_confirmed_htf = input.bool(true, "使用已确认HTF值(防重绘)", group="信号设置", 
                               tooltip="开启后只使用已收盘的HTF K线,避免回测与实盘不一致")
require_all_tf_confirmed = input.bool(true, "要求所有TF已确认", group="信号设置", 
                                     tooltip="即使关闭HTF确认模式,也要求所有TF的当前K线已收盘才触发信号")
trigger_on_close = input.bool(true, "仅在当前周期K线收盘时触发", group="信号设置", 
                              tooltip="避免当前周期实时K线内信号抖动")
cooldown_bars = input.int(5, "信号冷却周期", minval=0, group="信号设置", 
                          tooltip="两次信号之间至少间隔的K线数,0表示不限制")

// 标签管理
max_labels_show = input.int(50, "最大标签数量", minval=10, maxval=500, group="显示设置")

// ============================================
// EMA趋势判断函数(一次性获取所有值)
// ============================================
get_ema_trend(tf) =>
    // 一次性获取所有需要的值(包括HTF的确认状态和ATR)
    [ema9_0, ema21_0, ema9_1, ema21_1, ema9_2, ema21_2, tf_confirmed, tf_close_0, tf_close_1, tf_atr] = request.security(
         syminfo.tickerid, 
         tf, 
         [
             ta.ema(close, ema_fast),       // 当前EMA9
             ta.ema(close, ema_slow),       // 当前EMA21
             ta.ema(close[1], ema_fast),    // 上一根EMA9
             ta.ema(close[1], ema_slow),    // 上一根EMA21
             ta.ema(close[2], ema_fast),    // 上上根EMA9
             ta.ema(close[2], ema_slow),    // 上上根EMA21
             barstate.isconfirmed,          // HTF是否已确认
             close,                         // 当前收盘价
             close[1],                      // 上一根收盘价
             ta.atr(14)                     // ATR(14)
         ],
         barmerge.gaps_off,
         barmerge.lookahead_off
     )
    
    // 根据模式选择使用哪组值(包括价格基准)
    ema9_current = use_confirmed_htf ? ema9_1 : ema9_0
    ema21_current = use_confirmed_htf ? ema21_1 : ema21_0
    ema9_prev = use_confirmed_htf ? ema9_2 : ema9_1
    ema21_prev = use_confirmed_htf ? ema21_2 : ema21_1
    norm_price = use_confirmed_htf ? tf_close_1 : tf_close_0  // 修复：使用同一时点的价格
    
    // 计算斜率
    ema9_slope_up = ema9_current > ema9_prev
    ema21_slope_down = ema21_current < ema21_prev
    
    // EMA分离度检查(防止粘合假突破)
    ema_diff = math.abs(ema9_current - ema21_current)
    ema_separation_pct = ema_diff / norm_price * 100
    sufficient_separation = ema_separation_pct >= min_ema_separation
    
    // ATR波动过滤(可选)
    pass_atr_filter = not use_atr_filter or (ema_diff >= tf_atr * atr_multiplier)
    
    // 判断趋势
    // 1 = 看涨(EMA9在上且向上), -1 = 看跌(EMA21在上且向下), 0 = 中性
    trend = 0
    if ema9_current > ema21_current and ema9_slope_up and sufficient_separation and pass_atr_filter
        trend := 1
    else if ema21_current > ema9_current and ema21_slope_down and sufficient_separation and pass_atr_filter
        trend := -1
    
    [trend, tf_confirmed]

// ============================================
// 获取4个时间框架的趋势
// ============================================
[trend1, tf1_confirmed] = get_ema_trend(tf1)
[trend2, tf2_confirmed] = get_ema_trend(tf2)
[trend3, tf3_confirmed] = get_ema_trend(tf3)
[trend4, tf4_confirmed] = get_ema_trend(tf4)

// 所有TF是否已确认
all_tf_confirmed = tf1_confirmed and tf2_confirmed and tf3_confirmed and tf4_confirmed

// ============================================
// 信号生成逻辑(带完整保护机制)
// ============================================
confirmed_count_bullish = (trend1 == 1 ? 1 : 0) + (trend2 == 1 ? 1 : 0) + (trend3 == 1 ? 1 : 0) + (trend4 == 1 ? 1 : 0)
confirmed_count_bearish = (trend1 == -1 ? 1 : 0) + (trend2 == -1 ? 1 : 0) + (trend3 == -1 ? 1 : 0) + (trend4 == -1 ? 1 : 0)

// 根据模式判断信号
required_confirmations = signal_mode == "全部确认" ? 4 : 3

buy_signal = confirmed_count_bullish >= required_confirmations
sell_signal = confirmed_count_bearish >= required_confirmations

// TF确认保护
tf_condition_met = require_all_tf_confirmed ? all_tf_confirmed : true

// 冷却机制(买卖独立)
var int last_buy_bar = na
var int last_sell_bar = na

bars_since_last_buy = na(last_buy_bar) ? 999 : bar_index - last_buy_bar
bars_since_last_sell = na(last_sell_bar) ? 999 : bar_index - last_sell_bar
can_trigger_buy = bars_since_last_buy >= cooldown_bars
can_trigger_sell = bars_since_last_sell >= cooldown_bars

// 检测信号首次出现(带多重保护)
buy_signal_trigger = buy_signal and not buy_signal[1] and can_trigger_buy and tf_condition_met
sell_signal_trigger = sell_signal and not sell_signal[1] and can_trigger_sell and tf_condition_met

// 如果启用收盘确认,只在K线收盘时触发
buy_signal_new = trigger_on_close ? (buy_signal_trigger and barstate.isconfirmed) : buy_signal_trigger
sell_signal_new = trigger_on_close ? (sell_signal_trigger and barstate.isconfirmed) : sell_signal_trigger

// 更新冷却时间
if buy_signal_new
    last_buy_bar := bar_index
if sell_signal_new
    last_sell_bar := bar_index

// ============================================
// 绘制当前周期的EMA线
// ============================================
current_ema9 = ta.ema(close, ema_fast)
current_ema21 = ta.ema(close, ema_slow)

plot(show_ema_current ? current_ema9 : na, "EMA9", color=color.new(color.blue, 0), linewidth=2)
plot(show_ema_current ? current_ema21 : na, "EMA21", color=color.new(color.orange, 0), linewidth=2)

// ============================================
// 绘制买卖信号箭头
// ============================================
plotshape(buy_signal_new, "买入信号", shape.triangleup, location.belowbar, 
         color=color.new(color.green, 0), size=size.normal)
plotshape(sell_signal_new, "卖出信号", shape.triangledown, location.abovebar, 
         color=color.new(color.red, 0), size=size.normal)

// ============================================
// 标签管理(限制数量,带Y轴偏移)
// ============================================
var label[] buy_labels = array.new<label>()
var label[] sell_labels = array.new<label>()

if buy_signal_new
    // 构建触发详情
    triggered_tfs = ""
    triggered_tfs += trend1 == 1 ? "✓ " + tf1 + "\n" : ""
    triggered_tfs += trend2 == 1 ? "✓ " + tf2 + "\n" : ""
    triggered_tfs += trend3 == 1 ? "✓ " + tf3 + "\n" : ""
    triggered_tfs += trend4 == 1 ? "✓ " + tf4 : ""
    
    signal_text = "买入信号 [" + str.tostring(confirmed_count_bullish) + "/4]\n" + triggered_tfs
    
    // 使用yloc.belowbar避免遮挡
    new_label = label.new(bar_index, low, signal_text, 
                         yloc=yloc.belowbar,
                         style=label.style_label_up, 
                         color=color.new(color.green, 80), 
                         textcolor=color.white, 
                         size=size.small)
    
    array.push(buy_labels, new_label)
    
    // 删除超出限制的旧标签
    if array.size(buy_labels) > max_labels_show
        old_label = array.shift(buy_labels)
        label.delete(old_label)
    
    // 运行时动态警报
    alert("🔵 买入信号触发\n确认数: " + str.tostring(confirmed_count_bullish) + "/4\n" + triggered_tfs, 
          alert.freq_once_per_bar_close)

if sell_signal_new
    // 构建触发详情
    triggered_tfs = ""
    triggered_tfs += trend1 == -1 ? "✓ " + tf1 + "\n" : ""
    triggered_tfs += trend2 == -1 ? "✓ " + tf2 + "\n" : ""
    triggered_tfs += trend3 == -1 ? "✓ " + tf3 + "\n" : ""
    triggered_tfs += trend4 == -1 ? "✓ " + tf4 : ""
    
    signal_text = "卖出信号 [" + str.tostring(confirmed_count_bearish) + "/4]\n" + triggered_tfs
    
    // 使用yloc.abovebar避免遮挡
    new_label = label.new(bar_index, high, signal_text, 
                         yloc=yloc.abovebar,
                         style=label.style_label_down, 
                         color=color.new(color.red, 80), 
                         textcolor=color.white, 
                         size=size.small)
    
    array.push(sell_labels, new_label)
    
    // 删除超出限制的旧标签
    if array.size(sell_labels) > max_labels_show
        old_label = array.shift(sell_labels)
        label.delete(old_label)
    
    // 运行时动态警报
    alert("🔴 卖出信号触发\n确认数: " + str.tostring(confirmed_count_bearish) + "/4\n" + triggered_tfs, 
          alert.freq_once_per_bar_close)

// ============================================
// 多时间框架状态表格(修复创建/删除逻辑)
// ============================================
var table status_table = na

// 需要显示且表不存在时创建
if show_mtf_status and na(status_table)
    status_table := table.new(position.top_right, 3, 5, 
                             border_width=1, 
                             border_color=color.gray,
                             bgcolor=color.new(color.black, 85))
    
    // 表头
    table.cell(status_table, 0, 0, "时间框架", 
              bgcolor=color.new(color.gray, 60), 
              text_color=color.white, 
              text_size=size.small)
    table.cell(status_table, 1, 0, "趋势", 
              bgcolor=color.new(color.gray, 60), 
              text_color=color.white, 
              text_size=size.small)
    table.cell(status_table, 2, 0, "状态", 
              bgcolor=color.new(color.gray, 60), 
              text_color=color.white, 
              text_size=size.small)

// 不需要显示但表存在时删除
if not show_mtf_status and not na(status_table)
    table.delete(status_table)
    status_table := na

// 每根K线最后更新表格内容
if show_mtf_status and not na(status_table) and barstate.islast
    // TF1
    table.cell(status_table, 0, 1, tf1 + (tf1_confirmed ? "" : " ⏳"), 
              text_color=color.white, text_size=size.small)
    table.cell(status_table, 1, 1, trend1 == 1 ? "↑" : trend1 == -1 ? "↓" : "—", 
              bgcolor=trend1 == 1 ? color.new(color.green, 70) : trend1 == -1 ? color.new(color.red, 70) : color.new(color.gray, 80),
              text_color=color.white, text_size=size.normal)
    table.cell(status_table, 2, 1, trend1 == 1 ? "看涨" : trend1 == -1 ? "看跌" : "中性", 
              text_color=color.white, text_size=size.small)
    
    // TF2
    table.cell(status_table, 0, 2, tf2 + (tf2_confirmed ? "" : " ⏳"), 
              text_color=color.white, text_size=size.small)
    table.cell(status_table, 1, 2, trend2 == 1 ? "↑" : trend2 == -1 ? "↓" : "—",
              bgcolor=trend2 == 1 ? color.new(color.green, 70) : trend2 == -1 ? color.new(color.red, 70) : color.new(color.gray, 80),
              text_color=color.white, text_size=size.normal)
    table.cell(status_table, 2, 2, trend2 == 1 ? "看涨" : trend2 == -1 ? "看跌" : "中性", 
              text_color=color.white, text_size=size.small)
    
    // TF3
    table.cell(status_table, 0, 3, tf3 + (tf3_confirmed ? "" : " ⏳"), 
              text_color=color.white, text_size=size.small)
    table.cell(status_table, 1, 3, trend3 == 1 ? "↑" : trend3 == -1 ? "↓" : "—",
              bgcolor=trend3 == 1 ? color.new(color.green, 70) : trend3 == -1 ? color.new(color.red, 70) : color.new(color.gray, 80),
              text_color=color.white, text_size=size.normal)
    table.cell(status_table, 2, 3, trend3 == 1 ? "看涨" : trend3 == -1 ? "看跌" : "中性", 
              text_color=color.white, text_size=size.small)
    
    // TF4
    table.cell(status_table, 0, 4, tf4 + (tf4_confirmed ? "" : " ⏳"), 
              text_color=color.white, text_size=size.small)
    table.cell(status_table, 1, 4, trend4 == 1 ? "↑" : trend4 == -1 ? "↓" : "—",
              bgcolor=trend4 == 1 ? color.new(color.green, 70) : trend4 == -1 ? color.new(color.red, 70) : color.new(color.gray, 80),
              text_color=color.white, text_size=size.normal)
    table.cell(status_table, 2, 4, trend4 == 1 ? "看涨" : trend4 == -1 ? "看跌" : "中性", 
              text_color=color.white, text_size=size.small)

// ============================================
// 静态警报条件(用于创建警报)
// ============================================
alertcondition(buy_signal_new, "买入信号", "多时间框架确认买入信号")
alertcondition(sell_signal_new, "卖出信号", "多时间框架确认卖出信号")

// 背景高亮(与触发条件一致)
effective_buy_signal = buy_signal and tf_condition_met
effective_sell_signal = sell_signal and tf_condition_met
bgcolor(show_bgcolor ? (effective_buy_signal ? color.new(color.green, 95) : effective_sell_signal ? color.new(color.red, 95) : na) : na)
'''
